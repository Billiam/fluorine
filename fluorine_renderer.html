<!DOCTYPE html>
<html>
<head>
	<title>Fluorine</title>
	<style>
		body {
			margin: 0;
			border: 0;
			padding: 0;
			background-color: black;
			color: white;
			user-select: none;
			cursor: default;
			overflow: hidden;
		}
		#info_line {
			margin: 10px;		/* calculation below of info_line_height total size relies on this */
			border: 0;
			padding: 0;
			overflow: hidden;
		}
		#canvas {
		    padding-left: 0;
		    padding-right: 0;
		    margin-left: auto;
		    margin-right: auto;
		    display: block;
		}
	</style>
</head>
<body>

<div>
	<table style="width: calc(100% - 20px);" id="info_line"><tr>
		<td style="width: 80%" id="unitbox">&nbsp;</td>				<!-- Needs some content so it has its real size -->
		<td align="right" id="turnbox"></td>
	</tr></table>
</div>

<canvas id="canvas" width="100" height="100"></canvas>

<script>

	"use strict";

	const alert = require("./modules/alert");
	const fs = require("fs");
	const ipcRenderer = require("electron").ipcRenderer;
	const path = require("path");
	const stream = require("stream");
	const zstd = require("node-zstandard");

	const colours = ["#eeaaee", "#63ceca", "#ffbe00", "#c5ec98"];

	const canvas = document.getElementById("canvas");
	const context = canvas.getContext("2d");

	const info_line = document.getElementById("info_line");
	const unitbox = document.getElementById("unitbox");
	const turnbox = document.getElementById("turnbox");

	const info_line_height = info_line.offsetHeight + 20;		// relies on #info_line having margin of 10

	function make_renderer() {

		let renderer = Object.create(null);

		renderer.game = null;
		renderer.production_maps = null;
		renderer.filename = "";
		renderer.turn = 0;
		renderer.selection = null;
		renderer.width = 0;				// Grid width
		renderer.height = 0;			// Grid height

		renderer.open = (filename) => {

			console.log(`Trying to load ${filename}`);

			let ok = renderer.open_simple(filename);

			if (!ok && filename.endsWith() !== ".json") {
				renderer.open_zstd(filename);
			}
		}

		renderer.open_simple = (filename) => {

			// Returns false if it wasn't plain JSON.
			// Blocks while reading.

			try {
				let contents = fs.readFileSync(filename);
				renderer.game = JSON.parse(contents);
			} catch (err) {
				return false;
			}

			renderer.finish_load(filename);
			return true;
		}

		renderer.open_zstd = (filename) => {

			let warned = false;
			let all_chunks = [];
			let loading_stream = new stream.Writable();

			loading_stream._write = (chunk, encoding, done) => {
				all_chunks.push(chunk.toString());
				done();
			};

			// I believe the following is async (event loopy)...

			zstd.decompressFileToStream(filename, loading_stream, (err, result) => {
				if (err) {
					console.log("Loading failed (a).");
					if (!warned) {
						alert("Couldn't open this file.");
						warned = true;
					}
				}
				result.on("error", (err) => {
					console.log("Loading failed (b).");
					if (!warned) {
						alert("Couldn't open this file.");
						warned = true;
					}
				});
				result.on("finish", () => {
					try {
						renderer.game = JSON.parse(all_chunks.join(""));
					} catch (new_err) {
						console.log("Loading failed (c).");
						if (!warned) {
							console.log(new_err);
							alert("Couldn't open this file.");
							warned = true;
						}
						return;		// So finish_load() isn't called.
					}
					renderer.finish_load(filename);
				});
			});
		};

		renderer.finish_load = (filename) => {

			console.log("Loading seemed OK.");
			renderer.filename = filename;
			renderer.turn = 0;
			renderer.selection = null;

			renderer.width = renderer.game.production_map.width;
			renderer.height = renderer.game.production_map.height;

			renderer.make_production_maps();

			renderer.draw_title();
			renderer.draw();
		};

		renderer.draw_title = () => {

			if (!renderer.game) return;

			let player_names = [];

			for (let n = 0; n < renderer.game.players.length; n++) {
				let player = renderer.game.players[n];
				player_names.push(player.name)
			}

			document.title = player_names.join(" - ");
		};

		renderer.make_production_maps = () => {

			renderer.production_maps = [];			// Format is [turn][x][y]

			// Make frame 0 map...

			renderer.production_maps.push([]);
			for (let x = 0; x < renderer.width; x++) {
				renderer.production_maps[0].push([]);
				for (let y = 0; y < renderer.height; y++) {
					renderer.production_maps[0][x].push(renderer.game.production_map.grid[y][x].energy);	// Note reversed coords in JSON
				}
			}

			// Make the rest...

			for (let n = 1; n < renderer.game_length(); n++) {

				// Make this frame identical to the one before...

				renderer.production_maps.push([]);
				for (let x = 0; x < renderer.width; x++) {
					renderer.production_maps[n].push([]);
					for (let y = 0; y < renderer.height; y++) {
						renderer.production_maps[n][x].push(renderer.production_maps[n - 1][x][y]);
					}
				}

				// And now adjust for mining...

				let prior_frame = renderer.frame(n - 1);		// Can't use renderer.previous_frame() since turn isn't set

				for (let c = 0; c < prior_frame.cells.length; c++) {

					let cell = prior_frame.cells[c];

					let x = cell.x;
					let y = cell.y;
					let val = cell.production;

					renderer.production_maps[n][x][y] = val;
				}
			}
		};

		renderer.save = (filename) => {
			if (!filename || !renderer.game) return;
			fs.writeFileSync(filename, JSON.stringify(renderer.game, null, "\t"));
		};

		renderer.save_frame = (filename) => {
			alert("Not implemented.")
		};

		renderer.save_moves = (filename) => {
			alert("Not implemented.")
		};

		renderer.forward = (n) => {		// Negative arguments are allowed (go back).

			if (!renderer.game) {
				return;
			}

			renderer.turn += n;

			if (renderer.turn < 0) {
				renderer.turn = 0;
			}

			if (renderer.turn >= renderer.game_length()) {
				renderer.turn = renderer.game_length() - 1;
			}

			renderer.draw();
		};

		renderer.toggle = (varname) => {
			renderer[varname] = !renderer[varname];
			renderer.draw();
		};

		renderer.clear = () => {

			let available_width = window.innerWidth;
			let available_height = window.innerHeight - info_line_height;

			if (renderer.width <= 0 || renderer.height <= 0) {
				canvas.width = 100;
				canvas.height = 100;
			} else {
				canvas.width = Math.max(1, Math.floor(available_width / renderer.width)) * renderer.width;
				canvas.height = Math.max(1, Math.floor(available_height / renderer.height)) * renderer.height;
			}

			context.clearRect(0, 0, canvas.width, canvas.height);
		}

		renderer.draw = () => {

			renderer.clear();

			if (!renderer.game) {
				return;
			}

			renderer.draw_grid();
			renderer.draw_factories();
			renderer.draw_entities();
			renderer.draw_mining();
			renderer.draw_collisions();

			renderer.draw_info_line();

			renderer.send_info();
			renderer.send_events();

		};

		renderer.draw_info_line = () => {

			if (!renderer.selection) {
				unitbox.innerHTML = "no selection";
			} else if (renderer.selection.type === "box") {
				let val = renderer.production_maps[renderer.turn][renderer.selection.x][renderer.selection.y];
				unitbox.innerHTML = `Box ${renderer.selection.x}, ${renderer.selection.y} &mdash; ${val}`;
			} else if (renderer.selection.type === "ship") {

				let info = renderer.ship_info(renderer.selection.id);

				if (info === null && renderer.turn < renderer.selection.turn) {
					unitbox.innerHTML =
						`<span style="color: ${colours[renderer.selection.owner]};">Ship ${renderer.selection.id}</span> (not yet present)`;
				} else if (info === null) {
					unitbox.innerHTML =
						`<span style="color: ${colours[renderer.selection.owner]};">Ship ${renderer.selection.id}</span> (no longer present)`;
				} else {
					unitbox.innerHTML =
						`<span style="color: ${colours[renderer.selection.owner]};">Ship ${renderer.selection.id}</span> (${info.x}, ${info.y})`
						+ ` &mdash; <span style="color: ${colours[renderer.selection.owner]};">${info.energy}</span>`;
				}
			}

			turnbox.innerHTML = `${renderer.turn} / ${renderer.game_length() - 1}`;
		};

		renderer.ship_info = (id) => {

			// Returns null if the ship can't be found...

			for (let p = 0; p < renderer.game.players.length; p++) {

				let pents = renderer.current_frame().entities[p.toString()];

				if (pents === undefined) {
					continue;
				}

				let hit = pents[id.toString()];

				if (hit) {

					let ret = Object.create(null);

					ret.x = hit.x;
					ret.y = hit.y;
					ret.energy = hit.energy;
					ret.is_inspired = hit.is_inspired;

					return ret;
				}
			}

			return null;
		};

		renderer.draw_grid = () => {

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();

			for (let x = 0; x < renderer.width; x++) {
				for (let y = 0; y < renderer.height; y++) {
					let val = Math.floor(renderer.production_maps[renderer.turn][x][y] / 4);
					context.fillStyle = `rgb(${val},${val},${val})`;
					context.fillRect(x * box_width, y * box_height, box_width, box_height);
				}
			}
		};

		renderer.draw_factories = () => {

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();

			let players = renderer.game.players;

			for (let n = 0; n < players.length; n++) {

				let player = players[n];
				let colour = colours[n];
				let x = player.factory_location.x;
				let y = player.factory_location.y;

				context.fillStyle = colour;
				context.fillRect(x * box_width + box_width / 4, y * box_height + box_height / 4, box_width / 2, box_height / 2);

				// Circle...
				// context.beginPath();
				// context.arc(x * box_width + box_width / 2, y * box_height + box_height / 2, box_width / 2, 0, Math.PI * 2, true);
				// context.fill();
			}
		};

		renderer.draw_entities = () => {

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();
			let frame = renderer.current_frame();

			for (let n = 0; n < renderer.game.players.length; n++) {

				let colour = colours[n];

				let pents = frame.entities[n.toString()];

				if (pents === undefined) {
					continue;
				}

				for (let e in pents) {

					if (pents.hasOwnProperty(e) === false) {
						continue;
					}

					let entity = pents[e];

					let x = entity.x;
					let y = entity.y;

					context.fillStyle = colour;
					context.fillRect(x * box_width, y * box_height, box_width, box_height);
				}
			}
		};

		renderer.draw_mining = () => {

			if (renderer.turn <= 0) return;

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();

			let spots = renderer.previous_frame().cells;

			for (let n = 0; n < spots.length; n++) {

				let spot = spots[n];

				let x = spot.x;
				let y = spot.y;

				context.fillStyle = "#000000";
				context.fillRect(x * box_width + box_width / 4, y * box_height + box_height / 4, box_width / 2, box_height / 2);
			}
		};

		renderer.draw_collisions = () => {

			if (renderer.turn <= 0) return;

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();

			let events = renderer.previous_frame().events;

			for (let n = 0; n < events.length; n++) {

				if (events[n].type === "shipwreck") {

					let x = events[n].location.x;
					let y = events[n].location.y;

					context.fillStyle = "#ff0000";
					context.fillRect(x * box_width, y * box_height, box_width, box_height);
				}
			}
		};

		renderer.box_width = () => {
			return canvas.width / renderer.width;		// Elsewhere we ensure canvas size is a multiple of game width
		};

		renderer.box_height = () => {
			return canvas.height / renderer.height;		// Elsewhere we ensure canvas size is a multiple of game height
		};

		renderer.game_length = () => {
			return renderer.game.full_frames.length;
		}

		renderer.frame = (n) => {
			if (!renderer.game) return null;
			if (n < 0 || n >= renderer.game_length()) return null;
			return renderer.game.full_frames[n];
		}

		renderer.current_frame = () => {
			if (!renderer.game) return null;
			return renderer.frame(renderer.turn);
		}

		renderer.previous_frame = () => {
			if (!renderer.game) return null;
			if (renderer.turn <= 0) return null;
			return renderer.frame(renderer.turn - 1);
		}

		renderer.click = (event) => {

			if (!renderer.game) {
				return;
			}

			let x = Math.floor(event.offsetX / renderer.box_width());
			let y = Math.floor(event.offsetY / renderer.box_height());

			if (x < 0) x = 0;
			if (y < 0) y = 0;
			if (x >= renderer.width) x = renderer.width - 1;
			if (y >= renderer.height) y = renderer.height - 1;

			renderer.selection = renderer.selection_at(x, y);

			renderer.draw();
		};

		renderer.selection_at = (x, y) => {

			let s = Object.create(null);

			let frame = renderer.current_frame();

			for (let n = 0; n < renderer.game.players.length; n++) {

				let colour = colours[n];

				let pents = frame.entities[n.toString()];

				if (pents === undefined) {
					continue;
				}

				for (let e in pents) {

					if (pents.hasOwnProperty(e) === false) {
						continue;
					}

					let entity = pents[e];

					if (x === entity.x && y === entity.y) {
						s.type = "ship";
						s.turn = renderer.turn;
						s.id = parseInt(e, 10);
						s.owner = n;
						return s;
					}
				}
			}

			s.type = "box";
			s.x = x;
			s.y = y;

			return s;
		}

		renderer.send_info = () => {

			let lines = [];

			lines.push(`<p>${path.basename(renderer.filename)}</p>`);
			lines.push(`<p>${renderer.turn} / ${renderer.game_length() - 1}</p>`);

			// FIXME: add more info...

			ipcRenderer.send("relay", {
				receiver: "info",
				channel: "update",
				content: lines.join(""),
			});
		};

		renderer.send_events = () => {

			let lines = [];

			lines.push(`<p>${path.basename(renderer.filename)}</p>`);
			lines.push(`<p>${renderer.turn} / ${renderer.game_length() - 1}</p>`);

			// FIXME: add more info...

			ipcRenderer.send("relay", {
				receiver: "events",
				channel: "update",
				content: lines.join(""),
			});
		};

		return renderer;
	}

	let renderer = make_renderer();

	ipcRenderer.on("open", (event, filename) => {
		renderer.open(filename);
	});

	ipcRenderer.on("save", (event, filename) => {
		renderer.save(filename);
	});

	ipcRenderer.on("save_frame", (event, filename) => {
		renderer.save_frame(filename);
	});

	ipcRenderer.on("save_moves", (event, filename) => {
		renderer.save_moves(filename);
	});

	ipcRenderer.on("forward", (event, n) => {
		renderer.forward(n);
	});

	ipcRenderer.on("toggle", (event, varname) => {
		renderer.toggle(varname);
	});

	ipcRenderer.on("log", (event, msg) => {
		console.log(msg);
	});

	window.addEventListener("resize", () => renderer.draw());

	canvas.addEventListener("mousedown", (event) => renderer.click(event));

	// Setup drag-and-drop...

	window.ondragover = () => false;
	window.ondragleave = () => false;
	window.ondragend = () => false;
	window.ondrop = (event) => {
		event.preventDefault();
		renderer.open(event.dataTransfer.files[0].path);
		return false;
	};

	renderer.clear();

	// Give the window and canvas a little time to settle... (may prevent sudden jerk during load).

	setTimeout(() => {
		ipcRenderer.send("renderer_ready", null);
	}, 200);

</script>
</body>
</html>
